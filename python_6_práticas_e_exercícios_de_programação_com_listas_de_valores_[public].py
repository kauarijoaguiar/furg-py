# -*- coding: utf-8 -*-
"""Python 6 - Práticas e exercícios de programação com listas de valores [public]

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1woYy5nS1GK5E6O2SLCq0ngJsn5X4CJvX

# Instruções

- IMPORTANTE: primeiro clique no círculo preto com a seta branca abaixo.

- Faça as atividades em sequência, escrevendo ou alterando o trecho de código em cada célula para obter o resultado esperado.

- Use **SHIFT + ENTER** para executar o código. O resultado será exibido logo abaixo.

- Então valide o resultado com **SHIFT + ENTER** novamente, na célula que contém o comando **validar()**. Não remova ou altere esta linha.

- Você pode desfazer a alteração em qualquer célula usando **CONTROL + Z**.
"""

# Não se preocupe com este código. E nem faça alterações nele, por favor.

import builtins
import io

from IPython.core.display import display, HTML

# practice core v2.3

_INPUT = []
_PRINT = []

def input(*args, **kwargs):
    s = builtins.input(*args, **kwargs)
    _INPUT.append(s)
    return s

def print(*args, **kwargs):
    s = _sprint(*args, **kwargs)
    _PRINT.append(s)
    return builtins.print(s)

def _sprint(*args, end='', **kwargs):
    sio = io.StringIO()
    builtins.print(*args, **kwargs, end=end, file=sio)
    return sio.getvalue()

def _correct(msg='Correto!'):
    display(HTML('<p style="background-color: LawnGreen; color: black; padding: 8px 8px 8px 8px;"><b>{}</b></p>'.format(msg)))

def _incorrect(msg):
    display(HTML('<p style="background-color: Tomato; color: black; padding: 8px 8px 8px 8px;">{}</p>'.format(msg)))

def _hint(msg):
    display(HTML('<p style="background-color: LightBlue; color: black; padding: 8px 8px 8px 8px;">{}</p>'.format(msg)))

def _out(value): # expects a single value to be matched against the last cell result
    if repr(_) == repr(value):
        return 0

    if _ == '':
        _incorrect('Não houve resultado, verifique se você executou seu código com SHIFT+ENTER.')
        return 1
    
    if type(_) != type(value):
        if type(value) == int:
            _hint('Dica: o resultado precisa ser do tipo inteiro.')
        elif type(value) == float:
            _hint('Dica: o resultado precisa ser do tipo real.')
        elif type(value) == bool:
            _hint('Dica: o resultado precisa ser do tipo lógico.')
        elif type(value) == str:
            _hint('Dica: o resultado precisa ser do tipo string.')
        else:
            _hint('Dica: o resultado precisa ser de outro tipo.')
    _incorrect('Resultado incorreto, tente novamente.')
    return 1

def _src(*args): # expects a list of strings to be matched against the last cell executed
    result = 0
    for term in args:
        if term not in _i:
            _hint('Dica: verifique se você usou "{}" no seu código.'.format(term))
            result = 1
    return result

def _inp(*args): # expects a list of strings to be matched against the read input
    if repr(_INPUT) == repr(list(args)):
        return 0

    if len(_INPUT) == 0:
        _incorrect('Não houve entrada, verifique se você usou o comando "input()" no seu código.')
        return 1

    if len(_INPUT) != len(args):
        if len(args) == 1:
            _hint('Dica: é esperada apenas 1 entrada do usuário.')
        else:
            _hint('Dica: são esperadas {} entradas do usuário.'.format(len(args)))
    else:
        _incorrect('Entrada com dados diferentes do que foi solicitado, tente novamente.')
    return 1

def _pri(*args): # expects a list of strings to be matched against the printed output
    if repr(_PRINT) == repr(list(args)):
        return 0

    if len(_PRINT) == 0:
        _incorrect('Não houve saída, verifique se você usou o comando "print()" em seu código.')
        return 1

    if len(_PRINT) != len(args):
        if len(args) == 1:
            _hint('Dica: é esperada apenas 1 linha de saída.')
        else:
            _hint('Dica: são esperadas {} linhas de saída.'.format(len(args)))
    else:
        _incorrect('Saída incorreta, tente novamente.')
    return 1

def _var(**kwargs): # expects a dictionary of variable names and their respective values
    result = 0
    for name, value in kwargs.items():
        if name not in globals():
            _hint('Dica: a variável "{}" precisa ser declarada.'.format(name))
            result = 1
            continue

        if repr(globals()[name]) == repr(value):
            continue # OK by now

        if type(globals()[name]) != type(value):
            if type(value) == int:
                _hint('Dica: a variável "{}" precisa ser do tipo inteiro.'.format(name))
            elif type(value) == float:
                _hint('Dica: a variável "{}" precisa ser do tipo real.'.format(name))
            elif type(value) == bool:
                _hint('Dica: a variável "{}" precisa ser do tipo lógico.'.format(name))
            elif type(value) == str:
                _hint('Dica: a variável "{}" precisa ser do tipo string.'.format(name))
            else:
                _hint('Dica: a variável "{}" precisa ser de outro tipo.'.format(name))
        else:
            _incorrect('Resultado incorreto para a variável "{}".'.format(name))
        result = 1

    return result

def _typ(**kwargs): # expects a dictionary of variable names and their respective types
    result = 0
    for name, typ in kwargs.items():
        if name not in globals():
            _hint('Dica: a variável "{}" precisa ser declarada.'.format(name))
            result = 1
            continue

        if type(globals()[name]) == typ:
            continue # OK by now

        if typ == int:
            _hint('Dica: a variável "{}" precisa ser do tipo inteiro.'.format(name))
        elif typ == float:
            _hint('Dica: a variável "{}" precisa ser do tipo real.'.format(name))
        elif typ == bool:
            _hint('Dica: a variável "{}" precisa ser do tipo lógico.'.format(name))
        elif typ == str:
            _hint('Dica: a variável "{}" precisa ser do tipo string.'.format(name))
        else:
            _hint('Dica: a variável "{}" precisa ser de outro tipo.'.format(name))
        result = 1

    return result

def _clear():
    global _INPUT, _PRINT
    _INPUT = []
    _PRINT = []
    for name in set(globals()) - _GLOBALS:
        if not name.startswith('_'):
            #builtins.print('remove:', name)
            globals().pop(name)

def validar(n=None):
    if n == None:
        _incorrect('É preciso indicar o número da atividade. Volte o comando "validar" como estava antes!')
    elif _test(n) == 0:
        _correct()
    _clear()

_GLOBALS = set(globals())
_GLOBALS.add('_GLOBALS')
_GLOBALS.add('_test')

import datetime as _datetime

def _test(n):
    if   n ==  1: return _pri('o tamanho é 4')
    elif n ==  2: return _typ(v=list) + _src('in') + _pri('o valor 5 está presente')
    elif n ==  3: return _var(a=8) + _typ(v=list, i=int) + _src('while', 'len') + _pri('2')
    elif n ==  4: return _typ(v=list) + _src('len', '%') + _pri('[5, 5, 7, 3, 3, 1]')
    elif n ==  5: return _typ(v=list, np=int, ni=int) + _src('len', '%') + _pri('4 2')
    elif n ==  6: return _typ(v=list) + _src('len') + _pri('5', '4', '3', '2', '1')
    elif n ==  7: return _typ(v=list, r=list) + _src('len', 'append') + _pri('[5, 4, 3, 2, 1]')
    elif n ==  8: return _typ(v=list) + _src('len', '%') + _pri('9 6', '2 4', '8 5', '1 3')
    elif n ==  9: return _var(v=['um', 'dois', 'três', 'quatro', 'cinco'], n=2) + _src('or') + _inp('2') + _pri('dois')
    elif n == 10: return _var(n=10) + _inp('10') + _pri('[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]')
    elif n == 11: return _var(código=[12, 34, 56], preço=[1.39, 2.49, 3.89]) + _inp('34') + _pri('2.49')
    elif n == 12: 
        v = ['segunda-feira', 'terça-feira', 'quarta-feira', 'quinta-feira', 'sexta-feira', 'sábado', 'domingo']
        d = _datetime.datetime.now()
        return _pri(v[d.weekday()])

"""# Práticas

## Prática 1
Busque e corrija o erro de sintaxe no código para exibir o tamanho da lista **v**.
"""

v = [51, 32, 46,87]
n = len(v)
print('o tamanho é', n)

validar(1)

"""## Prática 2
Escreva um trecho de código que define a lista **v=[4, 2, 7, 5]** e imprime (se for o caso) a mensagem **o valor 5 está presente**, desta forma.
"""

v=[4, 2, 7, 5]
i=0
while v[i]!=5:
  i+=1
print('o valor 5 está presente')

validar(2)

"""## Prática 3
Escreva um trecho de código que define a variável **a=8** e a lista **v=[6, 2, 8, 1]**. O programa deve percorrer a lista usando a variável **i** até encontrar um valor igual a **a**, indicando neste momento o respectivo índice. Dica: **i** deve ir de 0 até o comprimento da lista menos um.
"""

v=[6, 2, 8, 1]
a=8
i=0
while i<len(v):
  i+=1
print('valor de a encontrado')

validar(3)

"""## Prática 4
Escreva um trecho de código que define a lista **v=[5, 4, 6, 3, 2, 1]**. O programa deve percorrer esta lista e trocar todos os valores pares pelos seus sucessores (por exemplo, 4 → 5). Imprima a lista modificada no final.
"""

v=[5, 4, 6, 3, 2, 1]
i=0
while i < len(v):
  if v[i]%2 == 0:
    v[i]=v[i]+1
  i+=1
print(v)

validar(4)

"""## Prática 5
Escreva um trecho de código que define a lista **v=[1, 4, 6, 5, 8, 2]**. O programa deve percorrer esta lista e contar o números de valores pares na variável **np** e o número de ímpares em **ni**. Imprima as duas contagens em uma só linha e nessa ordem ao final.
"""

v=[1, 4, 6, 5, 8, 2]
np=0
ni=0
i=0
while i< len(v):
  if v[i]%2==0:
    np+=1
  if v[i]%2!=0:
    ni+=1
  i+=1
print(f'os valores pares sao:{np}\nos valores impares sao:{ni}')

validar(5)

"""## Prática 6
Escreva um trecho de código que define a lista **v=[1, 2, 3, 4, 5]**. O programa deve imprimir os elementos desta lista em ordem reversa, um em cada linha.
"""

v=[1, 2, 3, 4, 5]
i = len(v)
while i>0:
  i-=1
  print(v[i])

validar(6)

"""## Prática 7
Escreva um trecho de código que define a lista **v=[1, 2, 3, 4, 5]**. O programa deve construir uma nova lista **r** contendo os mesmos elementos de **v**, porém em ordem reversa. Então imprima **r**.
"""

v=[1, 2, 3, 4, 5]
r=[]
i=len(v)
while i > 0:
  i-=1
  r.append(v[i])
print(r)

validar(7)

"""## Prática 8
Escreva um trecho de código que define a lista **v=[9, 6, 2, 4, 8, 5, 1, 3]**. O programa deve primeiro testar se o comprimento da lista é par. Se for, deve então percorrer a lista imprimindo os valores dois a dois (ou seja, imprimir **9 6**, depois **2 4** e assim por diante). Dica: você pode acessar tanto **v[i]** como **v[i+1]**.

"""

v=[9, 6, 2, 4, 8, 5, 1, 3]
tamanho = len(v)
i=0
if tamanho%2==0:
  while i< tamanho: 
    print(v[i], v[i+1])
    i+=2
if tamanho%2!=0:
  print("o tamanho da lista e um numero impar")

validar(8)

"""## Prática 9
Defina uma lista de _strings_ **v=['um', 'dois', 'três', 'quatro', 'cinco']**. Faça um programa que leia um valor inteiro **n**. Se o valor estiver fora do intervalo [1, 5] imprima **fora do intervalo**. Caso contrário imprima o número por extenso, usando **v**. Teste com 2.
"""

n=int(input())
v=['um', 'dois', 'três', 'quatro', 'cinco']
if n>=1 or n<=5:
 if n ==1:
  print(v[0])
 if n ==2:
  print(v[1])
 if n ==3:
  print(v[2])
 if n ==4:
  print(v[3])
 if n ==5:
  print(v[4])
else:
  print("fora do intervalo")

validar(9)

"""# Exercícios

## Exercício 10
Faça um programa que receba um valor inteiro **n** e construa uma lista com os quadrados dos números de 1 até **n**, inclusive. A lista deverá ser impressa na tela. Teste com uma entrada 10.
"""

n=int(input())
v=[]
i=1
c=n
quadrado=0
while i<=c:
  quadrado=i*i
  v.append(quadrado)
  i+=1
print(v)

validar(10)

"""## Exercício 11
Faça um programa que defina duas listas **código=[12, 34, 56]** e **preço=[1.39, 2.49, 3.89]**, representando três produtos com seus respectivos códigos e preços. Então solicite o código de um produto e apresente o preço correspondente. Teste com o código 34.
"""

código=[12, 34, 56]
preço=[1.39, 2.49, 3.89]
n=int(input())
i=0
while i < len(código):
  if n==código[i]:
    print(preço[i])
  i+=1

validar(11)

"""## Exercício 12
Faça um programa que defina uma lista com os nomes da semana (começando na **'segunda-feira'**). O programa deve importar o módulo **datetime** e usar a função **weekday()** para imprimir o dia de hoje.
"""

import datetime
dias=['segunda-feira','terca-feira','quarta-feira','quinta-feira','sexta-feira','sabado','domingo']
d = datetime.datetime.now()
print(dias[d.weekday()])

validar(12)



